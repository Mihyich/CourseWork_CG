// Алгоритм и пояснения в конце файла

#version 460 core

// Точечный источник света
struct PointLight
{
    vec3 position;   // Позиция
    float radius;    // Радиус действия
    vec3 color;      // Цвет
    float intensity; // Интенсивность
};

// Прожекторный источник света
struct SpotLight
{
    vec3 position;     // Позиция
    vec3 direction;    // Направление
    float innerCutoff; // Угол (в радианах) внутреннего конуса
    float outerCutoff; // Угол (в радианах) внешнего конуса
    float radius;      // Радиус действия
    vec3 color;        // Цвет
    float intensity;   // Интенсивность
};

// Универсальный источник света
struct Light
{
    vec3 position;     // Позиция
    vec3 direction;    // Направление
    vec3 color;        // Цвет
    vec2 option;       // Радиус действия и Интенсивность
    vec2 cutoff;       // Внутренний и внешний углы в радианах
    int type;          // Тип источника света: 0 - PointLight; 1
};

// Вершинные данные
struct RayTraceVertex
{
    // Позиция:
    float px;
    float py;
    float pz;
    // Нормаль:
    float nx;
    float ny;
    float nz;
}; // float - универсальное выравнивание, оно совпадает со своим размером и ничего не нужно конвертировать

// Вершинные данные треугольника для использования в шейдере
struct RayTraceVertexTriangle
{
    RayTraceVertex v1; // Вершина 1
    RayTraceVertex v2; // Вершина 2
    RayTraceVertex v3; // Вершина 3
};

// Ограничивающая сфера
struct RayTraceBS
{
    // центер:
    float cx;
    float cy;
    float cz;
    // радиус:
    float r;
}; // float - универсальное выравнивание...

// Индексы дочерних узлов дерева в массиве
struct RayTraceChildIndex
{
    int left;  // Индекс левого дочернего узла в массиве
    int right; // Индекс правого дочернего узла в массиве
};

// Индексы треугольников и матриц в отдельных массивах
struct RayTraceDataIndex
{
    int triangle; // Индекс треугольника (или -1, если это не лист)
    int matrix;   // Индекс матрицы (-1, если узел не относится к мешу)
};

// Bounding Volume Hierarchy
struct RayTraceBVHNode
{
    RayTraceBS BS;         // Ограничиавющая сфера
    RayTraceChildIndex CI; // Дочерние индексы
    RayTraceDataIndex DI;  // Индексы данных
    int parent;            // Индекс родительского узла (-1 если нет)
};

layout(std140, binding = 0) uniform Lighting
{
    // Входной буфер, описывающий источник света
    Light light;
};

layout(std430, binding = 1) buffer Triangles
{
    // Входной буфер, хранящий вершинные данные всей сцены
    RayTraceVertexTriangle triangles[];
};

layout(std430, binding = 2) buffer Matrices
{
    // Входной буфер, хранящий матрицы модели для каждого объекта в сцене
    mat4 matrices[];
};

layout(std430, binding = 3) buffer Bvh
{
    // Входной буфер, хранящий дерево BVH
    RayTraceBVHNode bvh[];
};

uniform vec3 viewPos;
uniform mat4 view;
uniform mat4 projection;

#define EPSILON 0.0001

layout(rgb32f, binding = 4) uniform image2D colorImage;

// Луч
struct Ray
{
    vec3 origin; // Начало луча
    vec3 dir;    // Направление луча
};

// Треугольник
struct Triangle
{
    vec3 v1; // 1 позиция вершины
    vec3 v2; // 2 позиция вершины
    vec3 v3; // 3 позиция вершины
};

// Отбраковка треугольников, повернутых спикой к лучу
// true - надо отбраковывать
// false - не надо
bool backFaceCulling(Triangle triangle, Ray ray)
{
    vec3 edge1 = triangle.v2 - triangle.v1;
    vec3 edge2 = triangle.v3 - triangle.v1;
    vec3 normal = cross(edge1, edge2);
    return dot(normal, ray.dir) > 0.0;
}

// Трассировка сферы
// Положительный результат даже если луч находится внутри сферы
bool traceRayBoundingSphere(RayTraceBS RTBS, Ray ray)
{
    vec3 oc = ray.origin - vec3(sphere.cx, sphere.cy, sphere.cz);

    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.r * sphere.r;

    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0)
    {
        return false;
    }
    
    float sqrtDisc = sqrt(discriminant);
    t1 = (-b - sqrtDisc) / (2.0 * a);
    t2 = (-b + sqrtDisc) / (2.0 * a);
    
    return t1 > 0.0 || t2 > 0.0;
}

// Трассировка треугольника (Möller–Trumbore)
// обещает обрабатывать как CWW треугольники, так и CW
bool traceRayTriangle(Triangle triangle, Ray ray)
{
    vec3 edge1 = triangle.v2 - triangle.v1;
    vec3 edge2 = triangle.v3 - triangle.v1;
    vec3 h = cross(ray.dir, edge2);
    float a = dot(edge1, h);

    if (a > -EPSILON && a < EPSILON)
        return false;
    
    float f = 1.0 / a;
    vec3 s = ray.origin - triangle.v1;
    float u = f * dot(s, h);

    if (u < 0.0 || u > 1.0)
        return false;

    vec3 q = cross(s, edge1);
    float v = f * dot(ray.dir, q);

    if (v < 0.0 || u + v > 1.0)
        return false;

    float t = f * dot(edge2, q);

    return t > EPSILON;
}

int skipSubTree

// Запуск обхода BVH дерева
void traceRayBVH(Ray ray)
{
    RayTraceBVHNode node; // Текущий узел BVH
    RayTraceBS TRBS; // Текущий огриничивающий объем (сфера)
    RayTraceVertexTriangle triangle; // Текущий треугольник
    mat4 model; // Текущая матрица модели
    int curIndex = 0; // Корневой узел в массиве ВСЕГДА лежит в самом начале
    int maxIndex = bvh.length() - 1; // Максимально возможный индекс

    vec4 tmpPos1;

    while (curIndex > -1)
    {
        // Получить текущий узел
        node = bvh[curIndex];

        // Если узел не связующий (нет матрицы)
        if (node.DI.matrix < 0)
        {
            // Все первые 3 под-пункта выполнены
            ++curIndex; // Вжух... (づ￣ 3￣)づ (Продолжить ПРЕФИКСНЫЙ обход дерева)
        }
        // Если узел связующий (есть матрица, но нет треугольника)
        else if (node.DI.triangle < 0)
        {
            // Подготовка данных
            model = matrices[node.DI.matrix]; // Матрицы модели
            TRBS.r = node.BS.r; // радиус ограничивающей сферы

            // Учет локальности данных* (перевод в мировые)
            tmpPos1 = model * vec4(node.BS.cx, node.BS.cy, node.BS.cz, 1.0);
            TRBS.cx = tmpPos1.x;
            TRBS.cy = tmpPos1.y;
            TRBS.cz = tmpPos1.z;

            // Трассировка
            if (traceRayBoundingSphere(TRBS, ray))
            {
                // Попал!

                // Все 3 под-пункта пункта 2 выполнены (погружение в дерево)
                ++curIndex; // Вжух... (づ￣ 3￣)づ
            }
            else
            {
                // Мимо!


            }
        }
    }
}

void main()
{
    Ray ray; // Я, лучик...

    // Координаты пикселя (x, y) на экране
    ivec2 pixelCoord = gl_GlobalInvocationID.xy;

    // Размеры изображения
    ivec2 imageSize = imageSize(colorImage);

    // Нормализация координат пикселя в диапазон [0, 1]
    vec2 uv = vec2(pixelCoord) / vec2(imageSize);

    // Конвертация UV в NDC: [-1, 1]
    vec2 screenSpace = uv * 2.0 - 1.0;

    // Перенос NDC в мировые координаты
    vec4 rayOrigin4D = inverse(projection * view) * vec4(screenSpace, -1.0, 1.0);

    // Учет перспективного деления, и мы имеем координату с экрана в мировом пространстве сцены
    ray.origin = rayOrigin4D.xyz / rayOrigin4D.w;

    // позиция камеры ВСЕГДА чуть ближе, чем проекционная плоскость усеченной пирамиды
    ray.dir = normalize(ray.origin - viewPos);
}

/*
===========================================================================================================
| Правила обхода дерева BVH:                                                                              |
===========================================================================================================

1. Если нет матрицы => нет ограничивающего объема => нечего трассировать

    1.1 Попытаться перейти в левый узел (должно получиться, иначе дерево структурировано с ошибками)

    1.2 Иначе в правый (хотя это не должно быть никогда)

    1.3 Иначе найти следующий узел при ПРЕФИКСНОМ обходе дерева (хотя и этого тоже не должно быть никогда)

2. Если есть матрица, но нет треугольника => есть ограничивающий объем => трассировка объема

    2.1 Попал:

        2.1.1 Попытаться перейти в левый узел (должно получиться, иначе дерево структурировано с ошибками)

        2.1.2 Иначе в правый (хотя это не должно быть никогда)

        2.1.3 Иначе найти следующий узел при ПРЕФИКСНОМ обходе дерева (хотя и этого тоже не должно быть никогда)

    2.2 Мимо: Вызвать процедуру поиска нового узла*

3. Если есть матрица и треугольник => в жопу ограничивающий объем => трассировка треугольника

    3.1 Попал: рассчитать освещение; Вызвать процедуру подъема по дереву

    3.2 Мимо: Вызвать процедуру подъема по дереву

===========================================================================================================
| Процедура переключения на следующий узел в BVH дереве:                                                  |
===========================================================================================================

BVH дерево строится ПРЕФИКСНО, соответственно его узлы и в массиве будут лежать в таком порядке,
в котором бы оно перебиралось ПРЕФИКСНО, использовав дочерние индексы.

Это прекрасно-удивительно-неожиданная информация дает выполнить переход к следующему узлу
с помощью всего лишь одной команды... += 1.

И соответсвенно, именно поэтому, корень дерева располагается в начале массива, а последний узел - в конце.

( ͠° ͟ʖ ͡°)

Что вообще касается операции "curIndex += 1":

Как уже говорилось, BVH расположено ПРЕФИКСНО по массиву, значит любое инкрементирование, равнозначно
продолжению ПРЕФИКСНОГО обхода BVH дерева.

И поэтому выполнение этого действия одним разом покрывает все 3 пункта: 1.1, 1.2 и 1.3

===========================================================================================================
| Процедура поиска нового узла*                                                                           |
===========================================================================================================

Чего нужно добиться? Нашелся СВЯЗЫВАЮЩИЙ узел, который провалил трассировку ограничивающего объема. 
Значит, все его дочерние узлы можно не проверять, так как они в нем и содержатся.

Вопрос в том, как, зная что ниже текущего узла идти бессмысленно, найти новый узел для проверки,
причем таким образом, чтобы выполнялись следующие условия:

1. Узел должен иметь минимально возможный индекс относительно массива bvh

2. Из узла невозможно добраться до исследуемого (тот с которого начался поиск) с помощью

ПРЕФИКСНОГО обхода с положительным шагом

3. Узел не может быть дочерним по отношению к исследоваемому (тот с которого начался поиск)

Иными словами, нужно найти минимальный индекс бОльший исследуемого, да еще и проверить,
чтобы это не потомок исследуемого.

Решение 1: (итеративный метод)

1. Найти самый крайний правый узел. Это будет треугольник (так задумывалось дерево)

2. К найденному индексу прибавить 1. Та-да, либо нашлась новая ветка, либо мы достигли лимит индексов

Решение 2: (ПИЗДЕЦ метод, ноооо вкусный) Пока не поддерживается

Так как, по итогу BVH - это БДДП (сука почти), если оставшееся дерево, начиная с исследуемого узла является
сбалансированным, то новый индекс высчитывается как 2 * right - lelt. Но к сожалению, это работает
не всегда. Скорее всего из-за не точностей при распределении треугольников...

Пока мысли только о том, что можно дополнить узлы информацией о том, является ли их
поддерево сбалансированным?

Поэтому пока что реализуем первый метод

===========================================================================================================
| Учет локальности данных*                                                                                |
===========================================================================================================

Чтобы при перестройке дерева BVH, не приходилось обновлять каждый треугольник заново,
используется массив матриц, к которым каждый узел имеет, ну или не имеет (не связующий), доступ по индексу.

В итоге, все данные изначально лежат без преобразований. Поэтому важно учитывать влияние матриц
как на треугольники, так и на ограничивающие объемы, которые в свою очередь, были вычислены на тех же
локальных данных.

*/