\chapter{Технологический раздел}

В данном разделе описаны используемые языки программирования и среда
разработки.

\section{Выбор языка программирования и среды разработки}

Исследование реализаций алгоритмов будет проведено на операционной системе
\text{«Windows»}. Поэтому для создания оконного приложения используется
интерфейс прикладного программирования Win32 API. Это набор функций
для создания программ, работающих под управлением Microsoft Windows 98,
Windows NT или Windows 2000. Все функции этого набора являются 32-битными,
что отражено в названии интерфейса~\cite{Win32Api_Shupak}.

Инициализация, заполнение, обновление и использование теневых карт
предполагается в шейдерных программах. Для этого требуется инициализация
контекста \textit{«OpenGL»} и загрузка необходимых расширений, 
позволяющих компилировать такие программы. Для того,
чтобы связать контекст и оконное приложение на операционной системе
\text{«Windows»} требуется непосредственно сама библиотека
\textit{«opengl32.lib»}~\cite{extOpenGL}.

В ходе разработки реализации алгоритмов теневых карт потребуется
использование матричных преобразований. Они должны не только позволять
производить непосредственно сами преобразования, но и удовлетворять
требованиям использования в шейдерных программах. А именно их представление
в памяти должно соответсвовать ожиданиям шейдеров. Для этого отдельно
разработан модуль линейной алгебры~\cite{Linal}.

Таким образом, в качестве среды программирования выбрана программа
\text{Visual Studio Code}. Основным языком программирования всего приложения
выбран \text{C++}. Для разработки модуля матричных преобразований выбран язык
\text{C}, который наибольшим образом схож с языком программирования шейдерных
программ -- \text{GLSL}.

\section{Исходные модули программы}

Программа для удобства разделена на модули:

\begin{enumerate}[label=\arabic*), labelsep=0.5em]
    \item модуль \text{«LA»} - статическая библиотека линейной алгебры, реализующая
    матричные преобразования, работу с векторами и кватернионами и обеспечивающая
    выравнивание данных в памяти, ожидаемое в шейдерных программах;
    \item модуль \text{«WINAPI»} - статическая библиотека, обеспечивающая создание
    оконного приложения с поддержкой инициализации контекста \textit{«OpenGL»} (версией 4.6)
    и их совместное связывание;
    \item модуль \text{«GLSL»} - статическая библиотека, предоставляющая компилирование, линкование,
    анализ шейдерных программ, оптимизирует рутинные действия при работе с шейдерами;
    \item модуль \text{«ShadowMap»} - статическая библиотека, в которую собраны исследуемые реализации
    алгоритмов теневых карт;
    \item модуль \text{«app»} является основным модулем всего приложения и связывает все
    модули, упомянутые выше, в единое целое.
\end{enumerate}

\subsection{Исходные файлы модуля \text{«LA»}}

В данной библиотеке реализованы такие математические объекты как:

\begin{itemize}[label=---]
    \item вектор с 2-мя компонентами,
    \item вектор с 3-мя компонентами,
    \item вектор с 4-мя компонентами,
    \item кватернион,
    \item матрица размерностью 2 на 2,
    \item матрица размерностью 3 на 3,
    \item матрица размерностью 4 на 4.
\end{itemize}

Файлы модуля представлены ниже:

\begin{itemize}[label=---]
    \item \textbf{заголовочные} файлы:
    \begin{enumerate}[label=\arabic*), labelsep=0.5em]
        \item \text{LA\_sup.h} -- объявление вспомогательных функций для данного модуля;
        \item \text{Matrix2D.h} -- объявление структуры матрицы размерностью 2 на 2 и функций по ее использованию;
        \item \text{Matrix3D.h} -- объявление структуры матрицы размерностью 3 на 3 и функций по ее использованию;
        \item \text{Matrix4D.h} -- объявление структуры матрицы размерностью 4 на 4 и функций по ее использованию;
        \item \text{Quaternion.h} -- объявление структуры кватерниона и функций по его использованию;
        \item \text{Vector2D.h} -- объявление структуры вектора с 2-мя компонентами и функций по его использованию;
        \item \text{Vector3D.h} -- объявление структуры вектора с 3-мя компонентами и функций по его использованию;
        \item \text{Vector4D.h} -- объявление структуры вектора с 4-мя компонентами и функций по его использованию;
    \end{enumerate}
    \item \textbf{исходные} файлы:
    \begin{enumerate}[label=\arabic*), labelsep=0.5em]
        \item \text{LA\_sup.c} -- реализация вспомогательных функций для данного модуля;
        \item \text{Matrix2D.c} -- реализация матричных функций для размерности 2 на 2;
        \item \text{Matrix3D.c} -- реализация матричных функций для размерности 3 на 3;
        \item \text{Matrix4D.c} -- реализация матричных функций для размерности 4 на 4;
        \item \text{Quaternion.c} -- реализация функций преобразований, задаваемых кватернионом;
        \item \text{Vector2D.c} --  реализация функций взаимодействия с 2-ух компонентными векторами;
        \item \text{Vector3D.c} --  реализация функций взаимодействия с 3-ех компонентными векторами;
        \item \text{Vector4D.c} --  реализация функций взаимодействия с 4-ех компонентными векторами;
    \end{enumerate}
\end{itemize}

\subsection{Исходные файлы модуля \text{«WINAPI»}}

Файлы модуля представлены ниже:

\begin{itemize}[label=---]
    \item \textbf{заголовочные} файлы:
    \begin{enumerate}[label=\arabic*), labelsep=0.5em]
        \item \text{winapi\_brush\_struct.h} -- объявление структуры кисти;
        \item \text{winapi\_brash.h} -- объявление класса, реализующего инициализацию, использование и освобождение кисти;
        \item \text{winapi\_char\_converter.h} -- объявление функций конвертации строк;
        \item \text{winapi\_choose\_color\_dialog.h} -- объявление функции вызова диалога выбора цвета;
        \item \text{winapi\_choose\_file\_dialog.h} -- объявление функции вызова диалога выбора файла;
        \item \text{winapi\_common.h} -- объявление вспомогательных функций, специфичных для данного модуля;
        \item \text{winapi\_console.h} -- объявление класса, обеспечивающего создание консоли и перенаправления потоков ввода-вывода;
        \item \text{winapi\_font\_common.h} -- объявление общих функций работы с шрифтами;
        \item \text{winapi\_font\_struct.h} -- объявление структуры шрифта;
        \item \text{winapi\_font.h} -- объявление класса, обеспечивающего создание, использование и освобождение шрифта;
        \item \text{winapi\_GLextensions.h} -- объявление функции загрузки расширений контекста \textit{«OpenGL»};
        \item \text{winapi\_GLwindow.h} -- объявление класса, реализующего создание, использование и освобождение окна, поддерживающего связывание с контекстом \textit{«OpenGL»}; 
        \item \text{winapi\_mat\_ext.h} -- объявление общих расчетных функций, специфичных для данного модуля;
        \item \text{winapi\_mouse.h} -- объявление класса мыши, реализующего взаимодействие с вводом мыши;
        \item \text{winapi\_str\_converter.h} -- объявление расширенных функций конвертации строк;
        \item \text{winapi\_window.h} -- объявление класса, реализующего создание, использование и освобождение окна;
    \end{enumerate}
    \item \textbf{исходные} файлы:
    \begin{enumerate}[label=\arabic*), labelsep=0.5em]
        \item \text{winapi\_brash.cpp} -- реализация класса, обеспечивающего инициализацию, использование и освобождение кисти;
        \item \text{winapi\_char\_converter.cpp} -- реализация функций конвертации строк;
        \item \text{winapi\_choose\_color\_dialog.cpp} -- реализация функции вызова диалога выбора цвета;
        \item \text{winapi\_choose\_file\_dialog.cpp} -- реализация функции вызова диалога выбора файла;
        \item \text{winapi\_common.cpp} -- реализация вспомогательных функций, специфичных для данного модуля;
        \item \text{winapi\_console.cpp} -- реализация класса, обеспечивающего создание консоли и перенаправления потоков ввода-вывода;
        \item \text{winapi\_font\_common.cpp} -- реализация общих функций работы с шрифтами;
        \item \text{winapi\_font.cpp} -- реализация класса, обеспечивающего создание, использование и освобождение шрифта;
        \item \text{winapi\_GLextensions.cpp} -- реализация функции загрузки расширений контекста \textit{«OpenGL»};
        \item \text{winapi\_GLwindow.cpp} -- реализация класса, обеспечивающего создание, использование и освобождение окна, поддерживающего связывание с контекстом \textit{«OpenGL»}; 
        \item \text{winapi\_mat\_ext.cpp} -- реализация общих расчетных функций, специфичных для данного модуля;
        \item \text{winapi\_mouse.cpp} -- реализация класса мыши, обеспечивающего взаимодействие с вводом мыши;
        \item \text{winapi\_str\_converter.cpp} -- реализация расширенных функций конвертации строк;
        \item \text{winapi\_window.cpp} -- реализация класса, обеспечивающего создание, использование и освобождение окна;
    \end{enumerate}
\end{itemize}

\subsection{Исходные файлы модуля \text{«GLSL»}}

Файлы модуля представлены ниже:

\begin{itemize}[label=---]
    \item \textbf{заголовочные} файлы:
    \begin{enumerate}[label=\arabic*), labelsep=0.5em]
        \item \text{shader\_extensions.h} -- объявление функций упрощения отправки данных в шейдерные программы;
        \item \text{shader.h} -- объявление класса, обеспечивающего компилирование, линкование и
        анализ шейдерных программ;
    \end{enumerate}
    \item \textbf{исходные} файлы:
    \begin{enumerate}[label=\arabic*), labelsep=0.5em]
        \item \text{shader\_extensions.cpp} -- реализация функций упрощения отправки данных в шейдерные программы;
        \item \text{shader.cpp} -- реализация класса, обеспечивающего компилирование, линкование и
        анализ шейдерных программ;
    \end{enumerate}
\end{itemize}

\subsection{Исходные файлы модуля \text{«ShadowMap»}}

Файлы модуля представлены ниже:

\begin{itemize}[label=---]
    \item \textbf{заголовочные} файлы:
    \begin{enumerate}[label=\arabic*), labelsep=0.5em]
        \item \text{DepthBufferGenerator.h} -- объявление функции создания теневой карты;
        \item \text{DepthBufferStruct.h} -- объявление структуры теневой карты;
        \item \text{ShadowMapMainRenderData.h} -- объявление структуры необходимых данных для
        стандартного алгоритма теневых карт;
        \item \text{ShadowMapPcfRenderData.h} -- объявление структуры необходимых данных для
        алгоритма теневых карт с фильтрацией (PCF);
        \item \text{ShadowMapNoiseRenderData.h} -- объявление структуры необходимых данных для
        алгоритма теневых карт с фильтрацией шумом (NOISE);
        \item \text{ShadowMapPcssRenderData.h} -- объявление структуры необходимых данных для
        алгоритма мягких теневых карт с фильтрацией (PCSS);
        \item \text{ShadowMapPcssNoiseRenderData.h} -- объявление структуры необходимых данных для
        алгоритма мягких теневых карт с фильтрацией шумом (PCSS-NOISE);
        \item \text{ShadowMap.h} -- объявление функций стандартного алгоритма теневых карт;
        \item \text{ShadowMapPcf.h} -- объявление функций алгоритма теневых карт с фильтрацией (PCF);
        \item \text{ShadowMapNoise.h} -- объявление функций алгоритма теневых карт с фильтрацией шумом (NOISE);
        \item \text{ShadowMapPcss.h} -- объявление функций алгоритма мягких теневых карт с фильтрацией (PCSS);
        \item \text{ShadowMapPcssNosie.h} -- объявление функций алгоритма мягких теневых карт с фильтрацией шумом (PCSS-NOISE);
    \end{enumerate}
    \item \textbf{исходные} файлы:
    \begin{enumerate}[label=\arabic*), labelsep=0.5em]
        \item \text{DepthBufferGenerator.cpp} -- реализация функции создания теневой карты;
        \item \text{ShadowMap.cpp} -- реализация функций стандартного алгоритма теневых карт;
        \item \text{ShadowMapPcf.cpp} -- реализация функций алгоритма теневых карт с фильтрацией (PCF);
        \item \text{ShadowMapNoise.cpp} -- реализация функций алгоритма теневых карт с фильтрацией шумом (NOISE);
        \item \text{ShadowMapPcss.cpp} -- реализация функций алгоритма мягких теневых карт с фильтрацией (PCSS);
        \item \text{ShadowMapPcssNosie.cpp} -- реализация функций алгоритма мягких теневых карт с фильтрацией шумом (PCSS-NOISE);
    \end{enumerate}
\end{itemize}

\subsection{Исходные файлы модуля \text{«app»}}

Файлы модуля представлены ниже:

\begin{itemize}[label=---]
    \item \textbf{заголовочные} файлы:
    \begin{enumerate}[label=\arabic*), labelsep=0.5em]
        \item \text{app\_args.h} -- объявление глобальных переменных приложения;
        \item \text{user\_msgs.h} -- объявление пользовательских событий;
        \item \text{resource.h} -- объявление индетификаторов элементов оконного приложения;
        \item \text{cpu\_stop\_watch.hpp}; -- реализация класса таймера;
        \item \text{cpu\_timing.h} -- объявление базового класса замера процессорного времени;
        \item \text{formater.h} -- объявление функций конвертации строки в число;
        \item \text{FpsSetterDialogProc.h} -- объявление функции обработки событий диалога установки числа обновления кадров в секунду;
        \item \text{general\_shadow\_options\_wnd\_proc.h} -- объявление функции обработки событий окна изменения общих параметров теней;
        \item \text{Light.h} -- объявление функций обновления данных UBO буфера;
        \item \text{lighting\_wnd\_proc.h} -- объявление функции обработки событий окна изменения параметров источника света;
        \item \text{LightStruct.h} -- объявление структуры, описывающей источник света с выравниванием, требуемым шейдерными программами;
        \item \text{main\_wnd\_proc.h} -- объявление функции обработки событий родительского окна;
        \item \text{ModelLoader.h} -- объявление функций загрузки трехмерной модели;
        \item \text{ModelLoaderDialogProc.h} -- объявление функции обработки событий диалога выбора загружаемой модели;
        \item \text{PlaneMeshGenerator.h} -- объявление функций создания специфичных примитивных трехмерных объектов;
        \item \text{ProjectionEnum.h} -- объявление перечисления режима проекции;
        \item \text{render\_wnd\_proc.h} -- объявление функции обработки событий окна отрисовки;
        \item \text{ResolutionMapLimit.h} -- объявление максимальных размеров теневых карт;
        \item \text{shadow\_wnd\_proc.h} -- объявление функции обработки событий окна держателя вкладок;
        \item \text{ShadowAlgEnum.h} -- объявление перечисления алгоритмов теней;
        \item \text{shadowMap\_wnd\_proc.h} -- объявление функции обработки событий окна изменения параметров тени;
        \item \text{time\_definers.h} -- объявление временных констант;
        \item \text{toolbar\_wnd\_proc.h} -- объявление функции обработки событий окна инструментов;
    \end{enumerate}
    \item \textbf{исходные} файлы:
    \begin{enumerate}[label=\arabic*), labelsep=0.5em]
        \item \text{cpu\_timing.cpp} -- реализация базового класса замера процессорного времени;
        \item \text{formater.cpp} -- реализация функций конвертации строки в число;
        \item \text{FpsSetterDialogProc.cpp} -- реализация функции обработки событий диалога установки числа обновления кадров в секунду;
        \item \text{general\_shadow\_options\_wnd\_proc.cpp} -- реализация функции обработки событий окна изменения общих параметров теней;
        \item \text{Light.cpp} -- реализация функций обновления данных UBO буфера;
        \item \text{lighting\_wnd\_proc.cpp} -- реализация функции обработки событий окна изменения параметров источника света;
        \item \text{main\_wnd\_proc.cpp} -- реализация функции обработки событий родительского окна;
        \item \text{main.cpp} -- точка входы программы;
        \item \text{ModelLoader.cpp} -- реализация функций загрузки трехмерной модели;
        \item \text{ModelLoaderDialogProc.cpp} -- реализация функции обработки событий диалога выбора загружаемой модели;
        \item \text{PlaneMeshGenerator.cpp} -- реализация функций создания специфичных примитивных трехмерных объектов;
        \item \text{render\_wnd\_proc.cpp} -- реализация функции обработки событий окна отрисовки;
        \item \text{shadow\_wnd\_proc.cpp} -- реализация функции обработки событий окна держателя вкладок;
        \item \text{shadowMap\_wnd\_proc.cpp} -- реализация функции обработки событий окна изменения параметров тени;
        \item \text{toolbar\_wnd\_proc.cpp} -- реализация функции обработки событий окна инструментов;
    \end{enumerate}
\end{itemize}

\section{Реализация алгоритмов}

В данном разделе будут описаны выбранные типы, структуры данных и
представлены реализации алгоритмов теней.

\subsection{Типы и структуры данных}

В листинге~\ref{lst:light_struct} представлена структура, описывающая источник
освещения в Ламбертовой модели с учетом выравнивания памяти, ожидаемой в шейдерных
программах.

Чтобы передать структуру с ожидаемым расположением полей в структуре в шейдер 
необходимо следовать следующим правилам.

\begin{enumerate}[label=\arabic*), labelsep=0.5em]
    \item Если элемент представляет собой скаляр, использующий \(N\) базовых машинных единиц,
    базовое выравнивание равно \(N\).
    \item Если элемент представляет собой двух- или четырехкомпонентный вектор с компонентами
    при использовании \(N\) базовых машинных единиц базовое выравнивание равно \(2N\) или
    \(4N\) соответственно.
    \item Если элемент представляет собой трехкомпонентный вектор с компонентами, занимающими
    \(N\) базовых машинных единиц, базовое выравнивание равно \(4N\).
    \item Если элемент представляет собой массив скаляров или векторов, базовое выравнивание
    и шаг массива устанавливаются в соответствии с базовым выравниванием отдельного элемента массива
    в соответствии с правилами (1), (2) и (3) и округляются в большую сторону
    к базовому выравниванию четырехкомпонентного вектора. Массив может содержать отступы в начале
    и конце. Базовое смещение элемента, следующего за массивом, округляется в большую сторону
    до следующего значения, кратного базовому выравниванию.
    \item Если элемент представляет собой матрицу, состоящую из \(C\) столбцов и \(R\)
    строк, матрица хранится идентично массиву из \(C\)
    векторов с \(R\) компонентами в каждой строке, согласно правилу (4).
    \item Если элемент является массивом из \(S\) столбцов, то матрица хранится идентично строке векторов-столбцов \(S \times C\) с
    компонентами \(R\) в каждом, согласно правилу (4).
    \item Если элемент представляет собой матрицу, состоящую из \(C\) столбцов и \(R\) строк,
    то матрица сохраняется идентично массиву векторов с \(R\) строками с \(C\) компонентами,
    согласно правилу (4).
    \item Если элемент представляет собой массив из \(S\) матриц, состоящих из \(R\) строк
    и \(С\) столбцов, то матрица сохраняется идентично строке из \(S \times R\)
    векторов с \(C\) компонентами в каждой строке, согласно правилу (4).
    \item Если элемент является структурой, базовое выравнивание структуры равно
    \(N\), где \(N\) - наибольшее базовое значение выравнивания для любого из ее элементов,
    округленное до базового значения выравнивания для четырехкомпонентного вектора. Затем отдельным
    элементам этой подструктуры присваиваются смещения применяя набор правил рекурсивно,
    где базовое смещение первого элемента подструктуры равно выровненному смещению структуры.
    Структура может иметь отступы в конце; базовое смещение элемента, следующего за подструктурой,
    округляется в большую сторону к следующему кратному базовому выравниванию структуры.
    \item Если элемент представляет собой массив из \(S\) структур, элементы
    массива располагаются по порядку в соответствии с правилом (9).
\end{enumerate}

Рациональнее было бы использовать объединение - \text{union}, но GLSL его не
поддерживает~\cite{}.

\begin{center}
\captionsetup{justification=centering, singlelinecheck=off}
\begin{lstlisting}[label=lst:light_struct, caption={Источник освещения}]
struct Light
{
    // Кратность 16 ==================================================================
    vec3 position;     // Позиция (12 байт)
    float pad0;        // Выравнивание для GLSL vec3 (еще 4 байта)
    // Кратность 16 ==================================================================
    vec3 direction;    // Направление (12 байт)
    float pad1;        // Выравнивание для GLSL vec3 (еще 4 байта)
    // Кратность 16 ==================================================================
    vec3 color;        // Цвет (12 байт)
    float pad2;        // Выравнивание для GLSL vec3 (еще 4 байта)
    // Кратность 16 ==================================================================
    float radius;      // Радиус действия (4 байта)
    float intensity;   // Интенсивность (4 байта)
    float innerCutoff; // Угол (в радианах) внутреннего конуса (4 байта)
    float outerCutoff; // Угол (в радианах) внешнего конуса (4 байта)
    // Кратность 16 ==================================================================
    int   type;        // Тип источника света: 0 - PointLight; 1 - SpotLight (4 байта)
    float pad3;        // Дополнительные паддинги,
    float pad4;        // чтобы сделать размер структуры
    float pad5;        // кратным 16 (3 * 4 = 12 байт)
    // Кратность 16 ==================================================================
};
\end{lstlisting}
\end{center}

В листинге~\ref{lst:shadow_map_main_struct} представлена структура,
описывающая необходимые данные для алгоритма стандартных теневых карт.

\begin{center}
\captionsetup{justification=centering, singlelinecheck=off}
\begin{lstlisting}[label=lst:shadow_map_main_struct, caption={Структура параметров для стандартного алгоритма теневых карт}]
struct ShadowMapMainRenderData
{
    DepthBuffer* depthBuffer; // Структура теневой карты
    GLsizei* client_width;    // Ширина клиентской области рисования в пикселях
    GLsizei* client_height;   // Высота клиентской области рисования в пикселях

    Shader* shaderDepthPass;  // Объект класса шейдер
    Shader* shaderRenderPass; // Объект класса шейдер
    Shader* shaderDepthDebug; // Объект класса шейдер

    mat4* view;               // Матрица вида камеры пользователя
    mat4* projection;         // Матрица проекции камеры пользователя

    mat4* lightView;          // Матрица вида источника освещения
    mat4* lightProjection;    // Матрица проекции источника освещения

    GLfloat* shadowBias;      // Корректирующее смещение

    GLuint* quadVAO;          // Идентификатор буфера двумерного объекта, прямоугольник

    GLuint* planeVAO;         // Идентификатор буфера трехмерного объекта, плоскость
    mat4* planeModel;         // Матрица модели этого объекта

    GLuint* modelVAO;         // Идентификатор буфера трехмерного объекта
    GLsizei* modelIndexCount; // Количество индексов в этой модели
    mat4* modelModel;         // Матрица модели этого объекта
};
\end{lstlisting}
\end{center}

Для всех остальных алгоритмов теневых карт, помимо параметров
приведенных выше, требуется еще один параметр - \text{pcfRadius}.
Таким образом, структура выглядит как в
листинге~\ref{lst:shadow_map_pcf_struct}.

\begin{center}
\captionsetup{justification=centering, singlelinecheck=off}
\begin{lstlisting}[label=lst:shadow_map_pcf_struct, caption={Структура параметров для алгоритмов теневых карт с фильтрацией}]
struct ShadowMapMainRenderData
{
    DepthBuffer* depthBuffer; // Структура теневой карты
    GLsizei* client_width;    // Ширина клиентской области рисования в пикселях
    GLsizei* client_height;   // Высота клиентской области рисования в пикселях

    Shader* shaderDepthPass;  // Объект класса шейдер
    Shader* shaderRenderPass; // Объект класса шейдер
    Shader* shaderDepthDebug; // Объект класса шейдер

    mat4* view;               // Матрица вида камеры пользователя
    mat4* projection;         // Матрица проекции камеры пользователя

    mat4* lightView;          // Матрица вида источника освещения
    mat4* lightProjection;    // Матрица проекции источника освещения

    GLfloat* shadowBias;      // Корректирующее смещение
    GLfloat* pcfRadius;       // Радиус фильтрации

    GLuint* quadVAO;          // Идентификатор буфера двумерного объекта, прямоугольник

    GLuint* planeVAO;         // Идентификатор буфера трехмерного объекта, плоскость
    mat4* planeModel;         // Матрица модели этого объекта

    GLuint* modelVAO;         // Идентификатор буфера трехмерного объекта
    GLsizei* modelIndexCount; // Количество индексов в этой модели
    mat4* modelModel;         // Матрица модели этого объекта
};
\end{lstlisting}
\end{center}

В листингах~\ref{lst:shadow_map_main_struct}~--~\ref{lst:shadow_map_pcf_struct}
использовалась структура \text{теневой карты}. Она описана в
листинге~\ref{lst:shadow_map}.

\begin{center}
\captionsetup{justification=centering, singlelinecheck=off}
\begin{lstlisting}[label=lst:shadow_map, caption={Структура теневой карты}]
struct DepthBuffer
{
    GLuint Texture; // Идентификатор карты - текстуры
    GLuint FBO;     // Идентификатор кадрового буфера
    GLsizei width;  // Длина карты в пикселях
    GLsizei height; // Высота карты в пикселях
};
\end{lstlisting}
\end{center}

Все описанные алгоритмы, как представлено в
схемах~\ref{chart:shadow_map}~--~\ref{chart:shadow_map_pcss_noise},
имеют идентичный этап заполнения карты теней (листинг~\ref{lst:shadow_map_init}).
В этом участке кода, выполняется заполнение теневой карты, в которую заносится
информация глубины объекта.

\begin{center}
\captionsetup{justification=centering, singlelinecheck=off}
\begin{lstlisting}[label=lst:shadow_map_init, caption=Алгоритм заполнения теневой карты]
void DepthPass(ShadowMapMainRenderData& data)
{
    glViewport(0, 0, data.depthBuffer->width, data.depthBuffer->height);

    glBindFramebuffer(GL_FRAMEBUFFER, data.depthBuffer->FBO);
    glClear(GL_DEPTH_BUFFER_BIT);

    data.shaderDepthPass->use();
    uniform_matrix4f(data.shaderDepthPass->get_uniform_location("view"), data.lightView);
    uniform_matrix4f(data.shaderDepthPass->get_uniform_location("projection"), data.lightProjection);

    glBindVertexArray(*data.modelVAO);
    uniform_matrix4f(data.shaderDepthPass->get_uniform_location("model"), data.modelModel);
    glDrawElements(GL_TRIANGLES, *data.modelIndexCount, GL_UNSIGNED_INT, 0);
    glBindVertexArray(0);
}
\end{lstlisting}
\end{center}

\subsection{Алгоритм стандартных теневых карт}

\subsection{Алгоритм теневых карт с фильтрацией}

\subsection{Алгоритм теневых карт с фильтрацией шумом}

\subsection{Алгоритм мягких теневых карт с фильтрацией}

\subsection{Алгоритм мягких теневых карт с фильтрацией шумом}

\section*{Вывод}